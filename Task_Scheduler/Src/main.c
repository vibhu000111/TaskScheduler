/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);
void init_systick_timer(uint32_t tick_hz);

// some stack memory calculations


/*
#define SRAM_START 0x20000000U
#define SIZE_SRAM ((1024)*(128))

#define SRAM_END ((SRAM_START)+(SIZE_SRAM))
#define T1_STACK_START SRAM_END
#define T2_STACK_START ((SRAM_END) - (1 * SIZE_TASK_STACK))
#define T3_STACK_START ((SRAM_END) - (2 * SIZE_TASK_STACK))
#define T4_STACK_START ((SRAM_END) - (3 * SIZE_TASK_STACK))
#define SCHED_STACK_START ((SRAM_END) - (4 * SIZE_TASK_STACK))
#define DUMMY_XPSR 0x01000000
*/
#define SIZE_TASK_STACK          512U
#define SIZE_SCHED_STACK         512U

#define SRAM_START               0x20000000U
#define SIZE_SRAM                ( (128) * (1024))
#define SRAM_END                 ((((SRAM_START) + (SIZE_SRAM)) - 512U) )

#define T1_STACK_START           SRAM_END
#define T2_STACK_START           ( (SRAM_END) - (1 * SIZE_TASK_STACK))
#define T3_STACK_START           ( (SRAM_END) - (2 * SIZE_TASK_STACK) )
#define T4_STACK_START           ( (SRAM_END) - (3 * SIZE_TASK_STACK) )
#define SCHED_STACK_START        ( (SRAM_END) - (4 * SIZE_TASK_STACK) )
#define DUMMY_XPSR 0x01000000U

uint32_t psp_of_tasks[4] = {T1_STACK_START , T2_STACK_START , T3_STACK_START , T4_STACK_START}; //stores PSP of each task
uint32_t task_handler[4];


uint32_t curr_task = 0;

__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack);
void init_task_dummy();
void enable_fault_handler();
__attribute ((naked)) void switch_sp_to_psp();
void task1_handler(void); //This is task1
void task2_handler(void); //this is task2
void task3_handler(void); //this is task3
void task4_handler(void); // this is task4 of the application
void update_psp_of_task(uint32_t updated);
int next_task();





#define TICK_HZ 1U
#define HSI_CLK 16000000U
#define SYSTICK_TIM_CLK HSI_CLK


int main(void)
{
    /* Loop forever */
	enable_fault_handler();
	init_scheduler_stack(SCHED_STACK_START);
	init_task_dummy();


	init_systick_timer(TICK_HZ); //enables systick

	switch_sp_to_psp();
	task1_handler();


	for(;;);
}
void task1_handler(void)
{
	while(1)
	{
		printf("This is task1\n");
	}
}
void task2_handler(void)
{
	while(1)
	{
		printf("This is task2\n");
	}

}
void task3_handler(void)
{
	while(1)
	{
		printf("This is task3\n");
	}
}
void task4_handler(void){

	while(1)
	{
		printf("This is task4\n");
	}
}
void init_systick_timer(uint32_t tick_hz)
{
	uint32_t* SYST_RVR = (uint32_t*)0xE000E014;
	uint32_t count = (SYSTICK_TIM_CLK / tick_hz)-1;

	//clear value of rvr // 31:24 is reserved 23:0 is where data will be stored

	*SYST_RVR&= ~(0x00ffffff); //clears the 23:0
	*SYST_RVR|=count;

	//configure systick and control register refer manual
	/*
	 * [2] CLKSOURCE Indicates the clock source:
0 = external clock
1 = processor clock.
[1] TICKINT Enables SysTick exception request:
0 = counting down to zero does not assert the SysTick exception request
1 = counting down to zero asserts the SysTick exception request.
Software can use COUNTFLAG to determine if SysTick has ever counted to zero.
[0] ENABLE Enables the counter:
0 = counter disabled
1 = counter enabled
	 */

	uint32_t* SYST_csr =(uint32_t*) 0xE000E010;
	*SYST_csr|=(7 << 0); //clears the last 3 bits




}
void init_task_dummy()
{
	task_handler[0]=(uint32_t)task1_handler;
		task_handler[1]=(uint32_t)task2_handler;
		task_handler[2]=(uint32_t)task3_handler;
		task_handler[3]=(uint32_t)task4_handler;
	uint32_t* pPSP; // to iterate through process stack pointer of different tasks
	for(int i=0;i<4;i++)
	{
		pPSP = (uint32_t*) psp_of_tasks[i];

		*pPSP = DUMMY_XPSR ;// xpsr = 0x01000000 pPSP is storing mem location of stack that holds xpsr during exception return
		pPSP--;//PC

		*pPSP =  task_handler[i]; //location PC initialized
		pPSP--;//LR

		*pPSP = 0xFFFFFFFD; //EXC_RETURN when decoded tells the processor to use PSP in thread mode

		for(int j=1;j<=13;j++)
		{

			pPSP--;
			*pPSP=0;//initializing all general purpose registers
		}
		psp_of_tasks[i]=(uint32_t)pPSP;





	}

}

__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack) //naked funtion because cant access CPU registers in C
{
	__asm volatile("MSR MSP,%0"::"r"(sched_top_of_stack):);
	__asm volatile("BX LR"); //no epilogue that's why BX LR
}

void update_psp_of_task(uint32_t updated)
{
	psp_of_tasks[curr_task]=updated; //updates task1 PSP
}
int next_task()
{
	curr_task++;
	curr_task = curr_task%4;
	return(psp_of_tasks[curr_task]);//willbe passed as R0 arguement
}
__attribute ((naked))void SysTick_Handler (void)
{
	//this handler is running using MSP
	//1st task is to get PSP value
	__asm volatile ("MRS R0,PSP"); // since systick handler is using MSP so PSP holds the TASK1 PSP
	//2nd task is to SF2 to store state of task1 lets say
	__asm volatile("STMDB R0!,{R4-R11}"); // NOW r1 HOLDS the PSP of task1 after pushing R4-R11

	__asm volatile("PUSH {LR}"); // revisit
	//update the array index holding PSP for task1


	__asm volatile("BL update_psp_of_task"); //now R0 holding the value of new PSP for TASK1 is passed to
	//update_psp_of_task function as an arguement
	__asm volatile("BL next_task");

	//NOW r0 HOLDS THE PSP of task2
	//1st task is to retrieve the from stack mem to core

	__asm volatile("LDMIA R0!,{R4-R11}");
	__asm volatile("MSR PSP,R0"); //move address held in r0 to PSP
	__asm volatile("POP {LR}");
	__asm volatile("BX LR");
}

void enable_fault_handler()
{
	uint32_t* pSHCSR = (uint32_t*) 0xE000ED24;
	*pSHCSR|=(1<<16)|(1<<17)|(1<<18);
}

__attribute ((naked)) void switch_sp_to_psp() //naked because have to access SFR which can only be accessed in assembly
{
	__asm volatile (".EQU SRAM__END,((0x20000000 + (1024 *128))-512) ");
	__asm volatile ("LDR R0,=SRAM__END ");
	__asm volatile ("MSR PSP,R0"); //loading PSP with task1 PSP
	__asm volatile("MOV R0,#0x02");
	__asm volatile("MSR CONTROL,R0"); //SWITCHES sp TO USE psp
	__asm volatile("BX LR");
}
void HardFault_Handler()
{}
void MemManage_Handler()
{}
void BusFault_Handler ()
{}
void UsageFault_Handler()
{}
